using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;


// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace QuickType
{


    public partial class Welcome
    {
        [JsonProperty("marketSummaryResponse")]
        public MarketSummaryResponse MarketSummaryResponse { get; set; }
    }

    public partial class MarketSummaryResponse
    {
        [JsonProperty("result")]
        public List<Result> Result { get; set; }

        [JsonProperty("error")]
        public object Error { get; set; }
    }

    public partial class Result
    {
        [JsonProperty("fullExchangeName")]
        public string FullExchangeName { get; set; }

        [JsonProperty("exchangeTimezoneName")]
        public ExchangeTimezoneName ExchangeTimezoneName { get; set; }

        [JsonProperty("symbol")]
        public string Symbol { get; set; }

        [JsonProperty("regularMarketChange")]
        public RegularMarket RegularMarketChange { get; set; }

        [JsonProperty("gmtOffSetMilliseconds")]
        public long GmtOffSetMilliseconds { get; set; }

        [JsonProperty("exchangeDataDelayedBy")]
        public long ExchangeDataDelayedBy { get; set; }

        [JsonProperty("language")]
        public Language Language { get; set; }

        [JsonProperty("regularMarketTime")]
        public RegularMarket RegularMarketTime { get; set; }

        [JsonProperty("exchangeTimezoneShortName")]
        public ExchangeTimezoneShortName ExchangeTimezoneShortName { get; set; }

        [JsonProperty("regularMarketChangePercent")]
        public RegularMarket RegularMarketChangePercent { get; set; }

        [JsonProperty("quoteType")]
        public string QuoteType { get; set; }

        [JsonProperty("marketState")]
        public MarketState MarketState { get; set; }

        [JsonProperty("regularMarketPrice")]
        public RegularMarket RegularMarketPrice { get; set; }

        [JsonProperty("market")]
        public string Market { get; set; }

        [JsonProperty("priceHint", NullValueHandling = NullValueHandling.Ignore)]
        public long? PriceHint { get; set; }

        [JsonProperty("tradeable")]
        public bool Tradeable { get; set; }

        [JsonProperty("sourceInterval")]
        public long SourceInterval { get; set; }

        [JsonProperty("exchange")]
        public string Exchange { get; set; }

        [JsonProperty("shortName", NullValueHandling = NullValueHandling.Ignore)]
        public string ShortName { get; set; }

        [JsonProperty("region")]
        public Region Region { get; set; }

        [JsonProperty("regularMarketPreviousClose")]
        public RegularMarket RegularMarketPreviousClose { get; set; }

        [JsonProperty("triggerable")]
        public bool Triggerable { get; set; }

        [JsonProperty("headSymbolAsString", NullValueHandling = NullValueHandling.Ignore)]
        public string HeadSymbolAsString { get; set; }

        [JsonProperty("currency", NullValueHandling = NullValueHandling.Ignore)]
        public string Currency { get; set; }

        [JsonProperty("longName", NullValueHandling = NullValueHandling.Ignore)]
        public string LongName { get; set; }

        [JsonProperty("quoteSourceName", NullValueHandling = NullValueHandling.Ignore)]
        public string QuoteSourceName { get; set; }
    }

    public partial class RegularMarket
    {
        [JsonProperty("raw")]
        public double Raw { get; set; }

        [JsonProperty("fmt")]
        public string Fmt { get; set; }
    }

    public enum ExchangeTimezoneName { AmericaNewYork, AsiaTokyo, EuropeLondon };

    public enum ExchangeTimezoneShortName { Bst, Edt, Jst };

    public enum Language { En, EnUs };

    public enum MarketState { Closed, Regular };

    public enum Region { Us };

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ExchangeTimezoneNameConverter.Singleton,
                ExchangeTimezoneShortNameConverter.Singleton,
                LanguageConverter.Singleton,
                MarketStateConverter.Singleton,
                RegionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ExchangeTimezoneNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExchangeTimezoneName) || t == typeof(ExchangeTimezoneName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "America/New_York":
                    return ExchangeTimezoneName.AmericaNewYork;
                case "Asia/Tokyo":
                    return ExchangeTimezoneName.AsiaTokyo;
                case "Europe/London":
                    return ExchangeTimezoneName.EuropeLondon;
            }
            throw new Exception("Cannot unmarshal type ExchangeTimezoneName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExchangeTimezoneName)untypedValue;
            switch (value)
            {
                case ExchangeTimezoneName.AmericaNewYork:
                    serializer.Serialize(writer, "America/New_York");
                    return;
                case ExchangeTimezoneName.AsiaTokyo:
                    serializer.Serialize(writer, "Asia/Tokyo");
                    return;
                case ExchangeTimezoneName.EuropeLondon:
                    serializer.Serialize(writer, "Europe/London");
                    return;
            }
            throw new Exception("Cannot marshal type ExchangeTimezoneName");
        }

        public static readonly ExchangeTimezoneNameConverter Singleton = new ExchangeTimezoneNameConverter();
    }

    internal class ExchangeTimezoneShortNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExchangeTimezoneShortName) || t == typeof(ExchangeTimezoneShortName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BST":
                    return ExchangeTimezoneShortName.Bst;
                case "EDT":
                    return ExchangeTimezoneShortName.Edt;
                case "JST":
                    return ExchangeTimezoneShortName.Jst;
            }
            throw new Exception("Cannot unmarshal type ExchangeTimezoneShortName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExchangeTimezoneShortName)untypedValue;
            switch (value)
            {
                case ExchangeTimezoneShortName.Bst:
                    serializer.Serialize(writer, "BST");
                    return;
                case ExchangeTimezoneShortName.Edt:
                    serializer.Serialize(writer, "EDT");
                    return;
                case ExchangeTimezoneShortName.Jst:
                    serializer.Serialize(writer, "JST");
                    return;
            }
            throw new Exception("Cannot marshal type ExchangeTimezoneShortName");
        }

        public static readonly ExchangeTimezoneShortNameConverter Singleton = new ExchangeTimezoneShortNameConverter();
    }

    internal class LanguageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Language) || t == typeof(Language?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "en":
                    return Language.En;
                case "en-US":
                    return Language.EnUs;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Language)untypedValue;
            switch (value)
            {
                case Language.En:
                    serializer.Serialize(writer, "en");
                    return;
                case Language.EnUs:
                    serializer.Serialize(writer, "en-US");
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class MarketStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MarketState) || t == typeof(MarketState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CLOSED":
                    return MarketState.Closed;
                case "REGULAR":
                    return MarketState.Regular;
            }
            throw new Exception("Cannot unmarshal type MarketState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MarketState)untypedValue;
            switch (value)
            {
                case MarketState.Closed:
                    serializer.Serialize(writer, "CLOSED");
                    return;
                case MarketState.Regular:
                    serializer.Serialize(writer, "REGULAR");
                    return;
            }
            throw new Exception("Cannot marshal type MarketState");
        }

        public static readonly MarketStateConverter Singleton = new MarketStateConverter();
    }

    internal class RegionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Region) || t == typeof(Region?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "US")
            {
                return Region.Us;
            }
            throw new Exception("Cannot unmarshal type Region");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Region)untypedValue;
            if (value == Region.Us)
            {
                serializer.Serialize(writer, "US");
                return;
            }
            throw new Exception("Cannot marshal type Region");
        }

        public static readonly RegionConverter Singleton = new RegionConverter();
    }
}
